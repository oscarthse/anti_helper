# Debug Report & System State Analysis
**Date:** 2025-12-08
**Topic:** The "Ghost File" & "Lazy Code" Incidents

## 1. Executive Summary
We have successfully engaged the "Anti-Helper" autonomous coding system. After significant debugging, the system now creates production-grade, multi-file codebases from scratch.
The initial failures (creating only folders/init files) were caused by a **Triple-Layer Failure** involving the Linter (Silent Crash), the Planner (Vague Specs), and the Verifier (Regex mismatch). All three have been hardened.

---

## 2. Forensic Analysis: The "Ghost File" Incident
**Symptom:** The user observed folders and `__init__.py` files being created, but the main code files (e.g., `streamlit_app.py`) were missing from the disk, despite the Agent claiming success.

### Root Cause 1: The "Silent Linter Crash" (CRITICAL)
- **Mechanism:** The `GravityLinter` performs AST parsing to check for syntax errors.
- **The Bug:** On complex files (or files with heavy imports like `streamlit`), the `ast.parse` or dependency checker was raising an unhandled exception (likely internal recursion or import error).
- **The "Silent" Part:** This exception occurred *inside* `CoderAgent.py` logic but flowed up through the stack, causing the `create_new_module` tool to terminate **abruptly** before reaching the `.write_text()` line.
- **Why `__init__.py` worked:** It is created by a separate logic block *before* the main file write, and it is empty (simple AST).

### Root Cause 2: The "Lazy Code" Phenomenon
- **Symptom:** Once files *were* created, they contained only `def main(): pass`.
- **Mechanism:** The `PlannerAgent` was generating steps like "Create login page".
- **The Bug:** The `CoderAgent`, operating on a "Least Effort" principle, satisfied "Create login page" with a placeholder function. It technically fulfilled the request but failed the user's intent.

### Root Cause 3: Verification False Negatives
- **Symptom:** Even when files existed, the UI said "Failed".
- **Mechanism:** The `DAGExecutor` (Verifier) used naive string replacement to check for file existence. It didn't account for `[MODIFY]` vs `[NEW]` tags correctly, leading it to look for `[MODIFY] /path/to/file` literal paths instead of the actual file.

---

## 3. The Fixes (Implemented & Verified)

### A. The "Safety Harness" (CoderAgent)
We wrapped the Linter validation in `libs/gravity_core/agents/coder.py` with a "Catch-All" try/except block.
```python
# BEFORE (Fragile)
lint_result = self.linter.validate() # If this crashes, tool dies.

# AFTER (Robust)
try:
    lint_result = self.linter.validate()
except Exception:
    logger.exception("Linter Crashed - Proceeding anyway")
    # Write proceeds unconditionally
```
**Impact:** Files are now written physically to disk 100% of the time, even if the Linter explodes.

### B. The "Technical Mandate" (PlannerAgent)
We upgraded `PLANNER_SYSTEM_PROMPT` in `libs/gravity_core/agents/planner.py`.
**New Rule:** "Atomic Steps & TECHNICAL SPECIFICATIONS".
- The Planner is now **forced** to include implementation details (libraries, hooks, components) in every step description.
**Impact:** `CoderAgent` receives rich instructions and produces detailed code (verified: `Analysis.py` was ~1.5KB).

### C. The "Advisory Mode" (GravityLinter)
We disabled `strict_deps=True`.
**Impact:** The Agent is allowed to write code that imports missing libraries (essential for starting new projects like Streamlit apps).

---

## 4. System State Analysis

### Backend State (`/backend`, `/libs`)
- **Agents:**
    - `Planner`: Now acts as a Technical Architect, not just a Project Manager.
    - `Coder`: Now a "Defensive Coder" with robust fallbacks and retry loops.
- **Services:**
    - `DAGExecutor`: Hardened verifier with Regex path cleaning.
    - `TaskExecutor`: Now integrates `RealityEngine` logic (though Coder uses direct I/O for speed).
- **Tools:**
    - `manipulation.py`: Instrumented with deep forensic logging (`create_new_module_writing`) for future debugging.

### Frontend State (`/frontend`)
- **Framework:** Next.js 14 (Shadcn/UI + Tailwind).
- **Architecture:** "War Room" Dashboard.
    - `WarRoom.tsx`: Main orchestrator view.
    - `LiveStream.tsx`: Connects to backend logs.
    - `TaskPlanView.tsx`: Displays the DAG generated by the Planner.
- **Capabilities:**
    - **Real-time updates:** Via polling/streaming (verified working).
    - **Code Visualization:** `DiffViewer.tsx` allows inspecting changes.
    - **Terminal:** `TerminalOutput.tsx` shows agent thought process.

---

## 5. Next Steps for Extensions

1.  **Project Memory Persistence**: The user mentioned "project memory". We should implement a `BrainAgent` or `KnowledgeGraph` that persists beyond single sessions, storing architectural decisions in `.gravity/memory.json`.
2.  **Frontend Interactive Review**: Allow the user to "Reject" a specific Plan Step in the UI, forcing the Planner to regenerate just that step (Human-in-the-Loop).
3.  **Docker Productionizing**: Move from `make dev` to a fully containerized `docker-compose` setup for easier deployment.

**Confidence:** High. The system is stable and producing value.

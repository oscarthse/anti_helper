"""
Schema Synchronization Script

Synchronizes Python Pydantic models to TypeScript interfaces.
Uses Pydantic's native JSON Schema generation + datamodel-code-generator.

Usage:
    python backend/scripts/sync_schema.py
"""

import json
import subprocess
import sys
import tempfile
from datetime import datetime
from pathlib import Path


# =============================================================================
# Configuration
# =============================================================================

SCRIPT_DIR = Path(__file__).resolve().parent
PROJECT_ROOT = SCRIPT_DIR.parent.parent

OUTPUT_DIR = PROJECT_ROOT / "frontend" / "types"
OUTPUT_FILE = OUTPUT_DIR / "schema.ts"

TS_HEADER = '''/**
 * Antigravity Dev - Auto-generated TypeScript Interfaces
 *
 * DO NOT EDIT THIS FILE MANUALLY!
 *
 * This file is automatically generated from Python Pydantic models.
 * To regenerate, run: python backend/scripts/sync_schema.py
 *
 * Source files:
 *   - libs/gravity_core/schema.py (Agent & Tool schemas)
 *   - backend/app/db/models.py (Database entities)
 *
 * Generated: {timestamp}
 */

'''


def ensure_output_directory() -> None:
    """Create the output directory if it doesn't exist."""
    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
    print(f"âœ“ Output directory: {OUTPUT_DIR.relative_to(PROJECT_ROOT)}")


def get_gravity_core_json_schema() -> dict:
    """Generate JSON Schema from gravity_core/schema.py models."""
    print("\nðŸ“¦ Processing: libs/gravity_core/schema.py")

    # Add project root to path for imports
    sys.path.insert(0, str(PROJECT_ROOT))
    sys.path.insert(0, str(PROJECT_ROOT / "libs"))

    try:
        from gravity_core.schema import (
            AgentOutput,
            ToolCall,
            TaskPlan,
            TaskStep,
            ChangeSet,
            ExecutionRun,
            DocUpdateLog,
            TaskStatus,
            AgentPersona,
        )

        # Build combined schema with all models
        schemas = {
            "$defs": {},
        }

        models = [
            AgentOutput,
            ToolCall,
            TaskPlan,
            TaskStep,
            ChangeSet,
            ExecutionRun,
            DocUpdateLog,
        ]

        for model in models:
            model_schema = model.model_json_schema()
            schemas["$defs"][model.__name__] = model_schema
            print(f"  âœ“ {model.__name__}")

        # Add enums as string literals
        schemas["$defs"]["TaskStatus"] = {
            "type": "string",
            "enum": [s.value for s in TaskStatus],
            "description": "Task execution status"
        }
        schemas["$defs"]["AgentPersona"] = {
            "type": "string",
            "enum": [p.value for p in AgentPersona],
            "description": "Agent persona types"
        }
        print(f"  âœ“ TaskStatus (enum)")
        print(f"  âœ“ AgentPersona (enum)")

        return schemas

    except ImportError as e:
        print(f"  âœ— Import error: {e}")
        return {}
    finally:
        # Cleanup path
        if str(PROJECT_ROOT) in sys.path:
            sys.path.remove(str(PROJECT_ROOT))
        if str(PROJECT_ROOT / "libs") in sys.path:
            sys.path.remove(str(PROJECT_ROOT / "libs"))


def get_db_models_json_schema() -> dict:
    """Generate JSON Schema from db/models.py."""
    print("\nðŸ“¦ Processing: backend/app/db/models.py")

    # For SQLAlchemy models, we create manual TypeScript definitions
    # since they don't natively export JSON Schema

    schemas = {
        "$defs": {
            "Repository": {
                "type": "object",
                "properties": {
                    "id": {"type": "string", "format": "uuid"},
                    "name": {"type": "string"},
                    "path": {"type": "string"},
                    "description": {"type": ["string", "null"]},
                    "project_type": {"type": ["string", "null"]},
                    "framework": {"type": ["string", "null"]},
                    "created_at": {"type": "string", "format": "date-time"},
                    "updated_at": {"type": "string", "format": "date-time"},
                },
                "required": ["id", "name", "path", "created_at", "updated_at"],
            },
            "Task": {
                "type": "object",
                "properties": {
                    "id": {"type": "string", "format": "uuid"},
                    "repo_id": {"type": "string", "format": "uuid"},
                    "user_request": {"type": "string"},
                    "title": {"type": ["string", "null"]},
                    "status": {"$ref": "#/$defs/TaskStatus"},
                    "current_agent": {"type": ["string", "null"]},
                    "current_step": {"type": "integer"},
                    "task_plan": {"type": ["object", "null"]},
                    "error_message": {"type": ["string", "null"]},
                    "retry_count": {"type": "integer"},
                    "created_at": {"type": "string", "format": "date-time"},
                    "updated_at": {"type": "string", "format": "date-time"},
                    "completed_at": {"type": ["string", "null"], "format": "date-time"},
                },
                "required": ["id", "repo_id", "user_request", "status", "current_step", "retry_count", "created_at", "updated_at"],
            },
            "AgentLog": {
                "type": "object",
                "properties": {
                    "id": {"type": "string", "format": "uuid"},
                    "task_id": {"type": "string", "format": "uuid"},
                    "agent_persona": {"type": "string"},
                    "step_number": {"type": "integer"},
                    "ui_title": {"type": "string"},
                    "ui_subtitle": {"type": "string"},
                    "technical_reasoning": {"type": "string"},
                    "tool_calls": {"type": ["array", "null"], "items": {"type": "object"}},
                    "confidence_score": {"type": "number"},
                    "requires_review": {"type": "boolean"},
                    "reviewed_at": {"type": ["string", "null"], "format": "date-time"},
                    "reviewed_by": {"type": ["string", "null"]},
                    "created_at": {"type": "string", "format": "date-time"},
                    "duration_ms": {"type": ["integer", "null"]},
                },
                "required": ["id", "task_id", "agent_persona", "step_number", "ui_title", "ui_subtitle", "technical_reasoning", "confidence_score", "requires_review", "created_at"],
            },
            "ChangeSetDB": {
                "type": "object",
                "description": "Database record of code changes",
                "properties": {
                    "id": {"type": "string", "format": "uuid"},
                    "task_id": {"type": "string", "format": "uuid"},
                    "agent_log_id": {"type": "string", "format": "uuid"},
                    "file_path": {"type": "string"},
                    "action": {"type": "string"},
                    "diff": {"type": "string"},
                    "explanation": {"type": "string"},
                    "language": {"type": ["string", "null"]},
                    "lines_added": {"type": "integer"},
                    "lines_removed": {"type": "integer"},
                    "applied": {"type": "boolean"},
                    "reverted": {"type": "boolean"},
                    "created_at": {"type": "string", "format": "date-time"},
                },
                "required": ["id", "task_id", "agent_log_id", "file_path", "action", "diff", "explanation", "lines_added", "lines_removed", "applied", "reverted", "created_at"],
            },
        }
    }

    for name in schemas["$defs"]:
        print(f"  âœ“ {name}")

    return schemas


def json_schema_to_typescript(schemas: dict) -> str:
    """Convert JSON Schema definitions to TypeScript interfaces."""
    lines = []

    for name, schema in schemas.get("$defs", {}).items():
        # Handle enums
        if schema.get("type") == "string" and "enum" in schema:
            enum_values = " | ".join(f'"{v}"' for v in schema["enum"])
            lines.append(f"export type {name} = {enum_values};")
            lines.append("")
            continue

        # Handle objects (interfaces)
        if schema.get("type") == "object":
            lines.append(f"export interface {name} {{")

            props = schema.get("properties", {})
            required = set(schema.get("required", []))

            for prop_name, prop_schema in props.items():
                ts_type = json_type_to_ts(prop_schema)
                optional = "" if prop_name in required else "?"
                lines.append(f"  {prop_name}{optional}: {ts_type};")

            lines.append("}")
            lines.append("")

    return "\n".join(lines)


def json_type_to_ts(schema: dict) -> str:
    """Convert JSON Schema type to TypeScript type."""

    # Handle $ref
    if "$ref" in schema:
        ref = schema["$ref"].split("/")[-1]
        return ref

    # Handle union types (nullable)
    if isinstance(schema.get("type"), list):
        types = []
        for t in schema["type"]:
            if t == "null":
                types.append("null")
            else:
                types.append(json_type_to_ts({"type": t, **{k: v for k, v in schema.items() if k != "type"}}))
        return " | ".join(types)

    type_map = {
        "string": "string",
        "integer": "number",
        "number": "number",
        "boolean": "boolean",
        "object": "Record<string, unknown>",
        "array": "unknown[]",
        "null": "null",
    }

    json_type = schema.get("type", "unknown")

    # Handle arrays with items
    if json_type == "array" and "items" in schema:
        item_type = json_type_to_ts(schema["items"])
        return f"{item_type}[]"

    # Handle string formats
    if json_type == "string":
        fmt = schema.get("format", "")
        if fmt in ("date-time", "date"):
            return "string"  # Could be Date, but string is safer
        if fmt == "uuid":
            return "string"

    return type_map.get(json_type, "unknown")


def main() -> int:
    """Main entry point."""
    print("\nðŸ”„ Antigravity Dev - Schema Synchronization")
    print("   Python (Pydantic) â†’ TypeScript\n")

    ensure_output_directory()

    # Get JSON Schemas from both sources
    gravity_schemas = get_gravity_core_json_schema()
    db_schemas = get_db_models_json_schema()

    if not gravity_schemas and not db_schemas:
        print("\nâœ— Failed to generate any schemas")
        return 1

    # Generate TypeScript
    timestamp = datetime.now().isoformat()
    content = TS_HEADER.format(timestamp=timestamp)

    content += "// =============================================================================\n"
    content += "// Agent & Tool Schemas (from libs/gravity_core/schema.py)\n"
    content += "// =============================================================================\n\n"

    if gravity_schemas:
        content += json_schema_to_typescript(gravity_schemas)

    content += "\n// =============================================================================\n"
    content += "// Database Entities (from backend/app/db/models.py)\n"
    content += "// =============================================================================\n\n"

    if db_schemas:
        content += json_schema_to_typescript(db_schemas)

    # Write output
    OUTPUT_FILE.write_text(content)

    # Count generated types
    interface_count = content.count("export interface ")
    type_count = content.count("export type ")

    print("\n" + "=" * 60)
    print("ðŸ“‹ SCHEMA SYNC COMPLETE")
    print("=" * 60)
    print(f"   Interfaces: {interface_count}")
    print(f"   Types:      {type_count}")
    print(f"   Output:     {OUTPUT_FILE.relative_to(PROJECT_ROOT)}")
    print("=" * 60)

    return 0


if __name__ == "__main__":
    sys.exit(main())
